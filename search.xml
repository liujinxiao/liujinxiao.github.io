<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx域名解析</title>
      <link href="/2019/10/27/nginx%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/10/27/nginx%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>nginx域名解析 </p><p>查找nginx位置  locate nginx.conf</p><p>1、若两个域名分别指向同一服务器ip的不同端口则需要配置两个server</p><p>在第二个服务中增加proxy_pass 指向对应的端口号即可</p><p>2、nginx -s reload  // 重启nginx</p><p>￼<br><img src="https://user-gold-cdn.xitu.io/2019/10/27/16e0da3f35c24257?w=2346&h=1768&f=png&s=411604" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被誉为神器的requestAnimationFrame</title>
      <link href="/2019/10/27/%E8%A2%AB%E8%AA%89%E4%B8%BA%E7%A5%9E%E5%99%A8%E7%9A%84requestAnimationFrame/"/>
      <url>/2019/10/27/%E8%A2%AB%E8%AA%89%E4%B8%BA%E7%A5%9E%E5%99%A8%E7%9A%84requestAnimationFrame/</url>
      
        <content type="html"><![CDATA[<h3 id="被誉为神器的requestAnimationFrame"><a href="#被誉为神器的requestAnimationFrame" class="headerlink" title="被誉为神器的requestAnimationFrame"></a>被誉为神器的requestAnimationFrame</h3><p> 参考文章<a href="https://www.cnblogs.com/xiaohuochai/p/5777186.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuochai/p/5777186.html</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔。</p><p>setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行</p><p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li><li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li><li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染机制</title>
      <link href="/2019/10/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h2><h3 id="浏览器的渲染机制一般分为以下几个步骤："><a href="#浏览器的渲染机制一般分为以下几个步骤：" class="headerlink" title="浏览器的渲染机制一般分为以下几个步骤："></a>浏览器的渲染机制一般分为以下几个步骤：</h3><ol><li>处理HTML并构建DOM树</li><li>处理CSS并构建CSSOM树</li><li>将DOM和CSSDOM合并成一个渲染树</li><li>根据渲染树来布局，计算每个节点的位置</li><li>调用GPU绘制，合成图层，显示在屏幕上。</li></ol><p><img src="https://i.imgur.com/UkcWpPL.png" alt="渲染机制"></p><blockquote><p>构建CSSOM树是一个非常消耗性能的过程，并且该过程会阻塞渲染，直到CSSOM树构建完成。所以应保证层级扁平，减少过度层叠，越是具体的CSS选择器越消耗性能</p></blockquote><blockquote><p>当HTML解析到<code>script</code>标签时，会暂停构建DOM树，完成后才会从暂停的地方重新开始。也就是说，如果想首屏渲染的越快，越不应该在首屏加载js文件。并且CSS也会影响JS的执行，只有当解析完样式表才会执行JS，所以，也可以认为这种情况下，CSS也会暂停构建DOM。</p></blockquote><h3 id="Load-和-DOMContentLoaded-区别"><a href="#Load-和-DOMContentLoaded-区别" class="headerlink" title="Load 和 DOMＣontentLoaded 区别"></a>Load 和 DOMＣontentLoaded 区别</h3><blockquote><p>Load事件触发代表页面的DOM，CSS，JS，图片已经全部加载完成。</p></blockquote><blockquote><p>DOMContentLoaded事件触发代表初始的HTML被完全加载和解析，不需要等待CSS JS 图片加载。</p></blockquote><h3 id="减少回流和重绘"><a href="#减少回流和重绘" class="headerlink" title="减少回流和重绘"></a>减少回流和重绘</h3><ol><li><p>使用<code>translate</code>替代<code>top</code></p></li><li><p>使用<code>visibility</code>替换<code>display:none</code>,因为前者只会引起重绘，而后者会引起回流(改变布局)</p></li><li><p>把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</p></li><li><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</p><p> for (let i = 0; i &lt; 1000; i++) {<br>   // 获取 offsetTop 会导致回流，因为需要去获取正确的值<br>   console.log(document.querySelector(‘.test’).style.offsetTop)<br> }</p></li><li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p></li><li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</p></li><li><p>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p></li><li><p>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Egg知识整理系列(一)</title>
      <link href="/2019/10/27/Egg%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E7%B3%BB%E5%88%97-%E4%B8%80/"/>
      <url>/2019/10/27/Egg%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E7%B3%BB%E5%88%97-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Egg知识整理系列-一"><a href="#Egg知识整理系列-一" class="headerlink" title="Egg知识整理系列(一)"></a>Egg知识整理系列(一)</h2><h3 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h3><p>Koa是由Express框架原班人马打造的全新web框架，与Express风格类似，底层都是沿用同一套Http基础库，但是有几项显著差别：</p><ul><li>Middleware洋葱圈模型：Koa中间件采用洋葱圈模型，所有的请求经过中间件都会执行两次，可以非常方便的实现后置处理逻辑；</li><li>Context：与Express中只有Requese和Response不同，Koa增加了Context作为上下文对象，可以在请求中将相关字段挂载在Context上。</li><li>异常处理：用户可以很方便的自定义错误处理中间件放在其他中间件之前，就可以捕获到异步或同步代码发生的错误。如：<pre class=" language-shell"><code class="language-shell">  async function onerror(ctx, next) {      try {          await next();      } catch (err) {          ctx.app.emit('error', err);          ctx.body = 'server error';          ctx.status = err.status || 500;      }  }</code></pre></li></ul><h3 id="Egg继承Koa"><a href="#Egg继承Koa" class="headerlink" title="Egg继承Koa"></a>Egg继承Koa</h3><p>众所周知，Koa框架是一个极简框架扩展性非常强，而Egg在此基础上做了增强。</p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>在Egg框架中，可以通过定义<code>app/extend/{application,context,request,response}.js</code>来扩展Koa框架中四个框架的原型，如在<code>app/extend/context.js</code>中定义如下代码：</p><pre class=" language-shell"><code class="language-shell">module.exports = {    get isXXX() {        return xxx;    }}</code></pre><p>在controller.js中，可以利用刚才的定义：</p><pre class=" language-shell"><code class="language-shell">exports.handler = ctx => {  ctx.body = ctx.isXXX ? 'is xxx' : 'is not xxx';};</code></pre><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>Egg提供了更加强大的插件机制，一个插件可以包含：</p><ul><li>extend: 扩展基础对象的上下文，提供各种工具类、属性。</li><li>middleware: 增加一个或多个中间件，提供请求的前置、后置处理逻辑。</li><li>config: 配置各个环境下插件自身的默认配置项。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac Source Tree fatal: Authentication failed解决办法</title>
      <link href="/2019/10/27/Mac-Source-Tree-fatal-Authentication-failed%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/10/27/Mac-Source-Tree-fatal-Authentication-failed%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="在git改完密码后，操作SourceTree会出现-Authentication-failed报错，是由sourceTree中保存的密码还是旧密码导致，此时需将SourceTree中的用户删掉，重新输入新的用户名密码即可。"><a href="#在git改完密码后，操作SourceTree会出现-Authentication-failed报错，是由sourceTree中保存的密码还是旧密码导致，此时需将SourceTree中的用户删掉，重新输入新的用户名密码即可。" class="headerlink" title="在git改完密码后，操作SourceTree会出现 Authentication failed报错，是由sourceTree中保存的密码还是旧密码导致，此时需将SourceTree中的用户删掉，重新输入新的用户名密码即可。"></a>在git改完密码后，操作SourceTree会出现 Authentication failed报错，是由sourceTree中保存的密码还是旧密码导致，此时需将SourceTree中的用户删掉，重新输入新的用户名密码即可。</h3><h3 id="分两步："><a href="#分两步：" class="headerlink" title="分两步："></a>分两步：</h3><p>1、点击软件左上角SourceTree -&gt; 偏好设置，如下图所示</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df3c7955bc3566?w=1306&h=1270&f=png&s=1010207" alt=""></p><p>2、点击弹框右上角“高级”，将下图红框中用户名移除掉即可。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df3c7de738922d?w=1292&h=1000&f=png&s=600178" alt=""></p><p>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SourceTree </tag>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的Event loop 与 Node的 Event loop</title>
      <link href="/2019/10/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84Event-loop-%E4%B8%8E-Node%E7%9A%84-Event-loop/"/>
      <url>/2019/10/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84Event-loop-%E4%B8%8E-Node%E7%9A%84-Event-loop/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器中的Event-loop-与-Node的-Event-loop"><a href="#浏览器中的Event-loop-与-Node的-Event-loop" class="headerlink" title="浏览器中的Event loop 与 Node的 Event loop##"></a>浏览器中的Event loop 与 Node的 Event loop##</h2><h5 id="参考链接https-yuchengkai-cn-docs-frontend-browser-html-poll"><a href="#参考链接https-yuchengkai-cn-docs-frontend-browser-html-poll" class="headerlink" title="参考链接https://yuchengkai.cn/docs/frontend/browser.html#poll"></a>参考链接<a href="https://yuchengkai.cn/docs/frontend/browser.html#poll" target="_blank" rel="noopener" title="参考链接">https://yuchengkai.cn/docs/frontend/browser.html#poll</a></h5><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ol><li>JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题。</li><li>HTML5 标准规定setTimeout这个函数第二个参数不得小于 4 毫秒，不足会自动增加。</li><li>浏览器正确的一次 Event loop 顺序是这样的<blockquote><p>执行同步代码，这属于宏任务。</p><p>执行栈为空，查询是否有微任务需要执行</p><p>执行所有微任务</p><p>必要的话渲染 UI</p><p>然后开始下一轮 Event loop，执行宏任务中的异步代码</p></blockquote><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><img src="https://user-gold-cdn.xitu.io/2019/1/13/1684523ab43808ad?w=440&h=417&f=png&s=9529" alt="Node Event Loop"></li></ol><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>timers 阶段会执行 setTimeout 和 setInterval</p><p>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。</p><p>下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为 1。</p><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调</p><h4 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle, prepare"></a>idle, prepare</h4><p>idle, prepare 阶段内部实现</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 阶段很重要，这一阶段中，系统会做两件事情</p><p>执行到点的定时器<br>执行 poll 队列中的事件<br>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><p>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制<br>如果 poll 队列为空，会有两件事发生<br>如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate<br>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调<br>如果有别的定时器需要被执行，会回到 timer 阶段执行回调。</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>check 阶段执行 setImmediate</p><h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>close callbacks 阶段执行 close 事件</p><p>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署NodeJs实践（二、部署images和容器）</title>
      <link href="/2019/10/27/Docker%E9%83%A8%E7%BD%B2NodeJs%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%E3%80%81%E9%83%A8%E7%BD%B2images%E5%92%8C%E5%AE%B9%E5%99%A8%EF%BC%89/"/>
      <url>/2019/10/27/Docker%E9%83%A8%E7%BD%B2NodeJs%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%E3%80%81%E9%83%A8%E7%BD%B2images%E5%92%8C%E5%AE%B9%E5%99%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本NodeJs工程基于node-v8的docker镜像版本。</p><h2 id="1、Dockerfile文件"><a href="#1、Dockerfile文件" class="headerlink" title="1、Dockerfile文件"></a>1、Dockerfile文件</h2><p>首先，在node工程的根目录创建Dockerfile文件，该文件是node工程中对docker的配置文件。</p><p>1、创建Dcokerfile文件</p><pre><code>vi Dockerfile</code></pre><p>2、编写文件内容如下：</p><pre><code>#node镜像版本FROM node:8-alpine#声明作者MAINTAINER LIU#在image中创建文件夹RUN mkdir -p /home/Service#将该文件夹作为工作目录WORKDIR /home/Service# 将node工程下所有文件拷贝到Image下的文件夹中COPY . /home/Service#使用RUN命令执行npm install安装工程依赖库RUN npm install#暴露给主机的端口号EXPOSE 8888#执行npm start命令，启动Node工程CMD [ "npm", "start" ]</code></pre><h2 id="2、构建image"><a href="#2、构建image" class="headerlink" title="2、构建image"></a>2、构建image</h2><p>执行命令<code>docker build -t node-app:v1 .</code>&nbsp;需要注意v1后面还有一个<code>.</code><br /><br>其中 -t node-app:v1 为构建的镜像名称及标签</p><pre><code>[root@localhost test1]# docker build -t node-app:v1 .Sending build context to Docker daemon 4.096 kBStep 1/8 : FROM node:8-alpine ---> dd574b216ad7Step 2/8 : MAINTAINER LIU ---> Using cache ---> f3f22f068507Step 3/8 : RUN mkdir -p /home/Service ---> Using cache ---> 2222ce103ae1Step 4/8 : WORKDIR /home/Service ---> Using cache ---> e60fd914f709Step 5/8 : COPY . /home/Service ---> Using cache ---> 58000275f835Step 6/8 : RUN npm install ---> Using cache ---> e66dc16c44f4Step 7/8 : EXPOSE 8888 ---> Using cache ---> 2adff3739104Step 8/8 : CMD npm start ---> Using cache ---> 190fba2814a6Successfully built 190fba2814a6</code></pre><p>查看生成的image: <code>docker images</code>命令</p><pre><code>[root@localhost test1]# docker imagesREPOSITORY              TAG                 IMAGE ID            CREATED             SIZEnode-app                v1                  190fba2814a6        2 months ago        71 MB</code></pre><h2 id="3、运行container"><a href="#3、运行container" class="headerlink" title="3、运行container"></a>3、运行container</h2><blockquote><p>执行命令 <code>docker run -d -p 8888:8888 190f</code> <br /><br>其中， -d表示在容器后台运行，-p表示端口映射，将本机的8888端口映射到container的8888端口，外网访问本机的8888端口即可访问container。190f为生成的IMAGE的ID,只需要写入对应ID的前几位系统能辨识出对应的image即可。</p></blockquote><pre><code>[root@localhost test1]# docker run -d -p 8888:8888 190f1b335de60ff4ad0f75aa6c4458d4e91cc3839f6e606c5b09ff926bcebd6c9770</code></pre><blockquote><p>执行命令<code>docker ps</code>查看container是否运行</p></blockquote><pre><code>[root@localhost test1]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES1b335de60ff4        190f                &quot;npm start&quot;         4 seconds ago       Up 3 seconds        0.0.0.0:8888-&gt;8888/tcp   epic_swartz</code></pre><blockquote><p>通过命令docker logs 1b335 还可查看container的日志</p></blockquote><pre><code>[root@localhost test1]# docker logs 1b335&gt; webtest@1.0.0 start /home/Service&gt; node server.jsRunning on http://localhost:8888</code></pre><blockquote><p>说明服务已经启动。</p></blockquote><h2 id="4、进入容器"><a href="#4、进入容器" class="headerlink" title="4、进入容器"></a>4、进入容器</h2><p>为了方便查看容器内部文件和调试，可以通过命令进入容器中。容器内部就像一个小型的linux系统一样。命令为<code>docker exec -it 1b33 /bin/sh</code></p><pre><code>[root@localhost test1]# docker exec -it 1b33  /bin/sh/home/Service # lsDockerfile         node_modules       package-lock.json  package.json       server.js</code></pre><h2 id="5、日志"><a href="#5、日志" class="headerlink" title="5、日志"></a>5、日志</h2><ul><li>docker镜像中node工程会有打印日志功能，因为docker容器一旦挂掉，容器中的文件也会访问不了，所以日志必须要放在docker镜像外的文件路径下。此时，必须要将centos系统中的日志文件目录挂在到docker容器中，在容器启动时开启数据卷，实现日志采集。<br/></li><li>在启动容器时，使用命令<code>docker run -d -p 8888:8888 -v /home/logs:/data/logs 190f</code>即可。<code>/home/logs</code>为centos系统中日志文件目录，<code>data/logs</code>为docker容器中node工程写入日志路径。</li><li>如果docker容器中工程需要写入文件，则在启动时要加上<code>--privileged=true</code>才可以。<h2 id="6、打包与解压"><a href="#6、打包与解压" class="headerlink" title="6、打包与解压"></a>6、打包与解压</h2><blockquote><p>如果没有私有仓库，则可以通过save和load命令来打包和解压。<br>save将docker镜像压缩为tar文件，load为将tar文件解压生成镜像。</p></blockquote></li></ul><pre><code>[root@localhost docker]# docker imagesREPOSITORY              TAG                 IMAGE ID            CREATED             SIZEnode-app                v1                  190fba2814a6        2 months ago        71 MB[root@localhost docker]# docker save 190fba -o /home/docker/node-app-1.0.tar[root@localhost docker]# ll-rw-------. 1 root root 78526976 8月  26 19:38 node-app-1.0.tar</code></pre><blockquote><p>其中<code>/home/docker</code>文件路径为tar存放目录，必须提前建好，docker不会自动创建。<br /><br>而解压命令为:</p></blockquote><pre><code>[root@localhost docker]# docker load &lt; /home/docker/node-app-1.0.tarLoaded image ID: sha256:190fba2814a66291d06368a8afef499aa6f96f5d6def0b808d1fa5b76d862d53</code></pre><blockquote><p>此时容器将部署到环境中,可使用<code>docker images</code>查看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署NodeJS实践(一、代理)</title>
      <link href="/2019/10/27/Docker%E9%83%A8%E7%BD%B2NodeJS%E5%AE%9E%E8%B7%B5-%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/10/27/Docker%E9%83%A8%E7%BD%B2NodeJS%E5%AE%9E%E8%B7%B5-%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本文在centos7系统中，采用Docker容器部署Nodejs工程。 Doceker版本1.31。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>1、在centos系统中安装docker后，有一些服务器是没有连接外网权限的，可以测试是否能ping通。如果ping不通，则需要配置代理。本系统具体的实际代理地址及端口号，输入env即可显示。</p><p>2、方法</p><blockquote><p>1、在<code>/etc/systemd/system</code>目录下创建一个的<code>docker.service.d</code>文件夹</p></blockquote><pre><code>mkdir -p /etc/systemd/system/docker.service.d</code></pre><blockquote><p>2、在<code>docker.service.d</code>文件夹下创建http-proxy.conf文件，并添加HTTP_PROXY变量，其中proxy-url和proxy-port分别改成实际情况的代理地址和端口：</p></blockquote><pre><code>Environment=&quot;HTTP_PROXY=http://proxy-addr:proxy-port/&quot;&quot;HTTPS_PROXY=https://proxy-addr&quot;</code></pre><blockquote><p>3、如果有不需要使用代理来访问的Docker registries，那么还需要制定NO_PROXY环境变量：</p></blockquote><pre><code>Environment=&quot;HTTP_PROXY=http://proxy-addr:proxy-port/&quot;&quot;NO_PROXY=localhost,127.0.0.0/8&quot;</code></pre><blockquote><p>4、更新配置：</p></blockquote><pre><code>daemon-reload </code></pre><blockquote><p>5、重启docker服务</p></blockquote><pre><code>restart docker</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
